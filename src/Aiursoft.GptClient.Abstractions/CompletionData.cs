using System.Text.Json.Serialization;

namespace Aiursoft.GptClient.Abstractions;

public class CompletionData
{
    /// <summary>
    /// The ID of the completion.
    /// </summary>
    [JsonPropertyName("id")]
    public string? Id { get; set; }

    /// <summary>
    /// The type of the object, which is always "text_completion".
    /// </summary>
    [JsonPropertyName("object")]
    public string? Object { get; set; }

    /// <summary>
    /// The timestamp when the completion was created.
    /// </summary>
    [JsonPropertyName("created")]
    public int? Created { get; set; }

    /// <summary>
    /// The name of the model used to generate the completion.
    /// </summary>
    [JsonPropertyName("model")]
    public string? Model { get; set; }

    /// <summary>
    /// The usage data for this completion.
    /// </summary>
    [JsonPropertyName("usage")]
    public UsageData? Usage { get; set; }

    /// <summary>
    /// The list of choices generated by the completion.
    ///
    /// For library users: Do NOT access neither Choices nor Message directly. Use GetContent() and SetContent() instead.
    /// </summary>
    [JsonPropertyName("choices")]
    // ReSharper disable once CollectionNeverUpdated.Global
    // ReSharper disable once CollectionNeverQueried.Global
    public List<ChoicesItemData>? Choices { get; set; } = [];

    /// <summary>
    /// For some API versions, the message is returned directly in the completion object.
    ///
    /// For library users: Do NOT access neither Choices nor Message directly. Use GetContent() and SetContent() instead.
    /// </summary>
    [JsonPropertyName("message")]
    public MessageData? Message { get; set; }

    public string GetThinkPart()
    {
        var content = GetFullContent();
        const string startTag = "<think>";
        const string endTag = "</think>";
        var startIdx = content.IndexOf(startTag, StringComparison.OrdinalIgnoreCase);
        var endIdx = content.IndexOf(endTag, StringComparison.OrdinalIgnoreCase);

        // Found think part, return the content between <think> and </think>
        if (startIdx != -1 && endIdx != -1 && endIdx > startIdx)
        {
            var thinkStart = startIdx + startTag.Length;
            var thinkPart = content.Substring(thinkStart, endIdx - thinkStart);
            return thinkPart.Trim();
        }

        // Return empty string if no think part found
        return string.Empty;
    }

    public string GetAnswerPart()
    {
        var content = GetFullContent();
        const string startTag = "<think>";
        const string endTag = "</think>";
        var startIdx = content.IndexOf(startTag, StringComparison.OrdinalIgnoreCase);
        var endIdx = content.IndexOf(endTag, StringComparison.OrdinalIgnoreCase);

        // If think part exists, the actual answer is the content after the think tag
        if (startIdx != -1 && endIdx != -1 && endIdx > startIdx)
        {
            var answerStart = endIdx + endTag.Length;
            return content.Substring(answerStart).Trim();
        }

        // If no think tag found, return the whole content as is
        return content;
    }

    public void FillBothChoices()
    {
        // if message.content is null while choices[0].message.content is not null, fill message.content with choices[0].message.content
        // if choices[0].message.content is null while message.content is not null, fill choices[0].message.content with message.content
        if (Message?.Content == null && Choices != null && Choices.Count != 0 && Choices.First().Message?.Content != null)
        {
            Message ??= new MessageData
            {
                Role = "assistant",
            };
            Message.Content = Choices.First().Message!.Content;
        }
        else if ((Choices == null || Choices.Count == 0 || Choices.First().Message?.Content == null) && Message?.Content != null)
        {
            Choices ??=
            [
                new ChoicesItemData()
                {
                    Message = new MessageData
                    {
                        Content = Message.Content,
                        Role = "assistant"
                    }
                }
            ];
        }
    }

    public string GetFullContent()
    {
        if (Choices != null && Choices.Count != 0)
        {
            return Choices.First().Message?.Content ?? string.Empty;
        }
        return Message?.Content ?? string.Empty;
    }

    public void SetContent(string content)
    {
        // Fill the Choices because some front-end code may rely on it.
        Choices =
        [
            new ChoicesItemData
            {
                Message = new MessageData
                {
                    Content = content,
                    Role = "assistant"
                }
            }
        ];

        // Fill the Message because some front-end code may rely on it.
        Message ??= new MessageData
        {
            Role = "assistant",
        };
        Message.Content = content;
    }
}
